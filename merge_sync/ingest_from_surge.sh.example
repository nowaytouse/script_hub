#!/usr/bin/env bash
# ============================================
# Script: Ingest Rules from Surge Profile
# Description:
#   Extracts "New" rules from Surge profile (above specific marker),
#   classifies them by policy, appends to local rulesets,
#   and removes them from the profile.
#
# IMPORTANT: Firewall Port Rules Exclusion
#   - Rules with IN-PORT/DEST-PORT/SRC-PORT are AUTOMATICALLY SKIPPED
#   - These rules should stay in the Firewall module
#   - Firewall rules are system-level security policies, NOT content filtering
# ============================================

set -e

# ============================================
# CONFIGURATION - EDIT THESE PATHS
# ============================================
PROFILE_PATH="/Users/YOUR_USERNAME/Library/Mobile Documents/iCloud~com~nssurge~inc/Documents/YOUR_PROFILE.conf"
MARKER="# ============ Above are new rules ============"
BACKUP_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/backup"
timestamp=$(date "+%Y%m%d_%H%M%S")

# Local Target Files
DIR_RULESET="$(cd "$(dirname "${BASH_SOURCE[0]}")/../ruleset" && pwd)"
DIR_CONF="$DIR_RULESET/Sources/conf"
DIR_CUSTOM="$DIR_RULESET/Sources/custom"

# Ensure dirs exist
mkdir -p "$DIR_CONF" "$DIR_CUSTOM"

# Categories / Files
FILE_ADBLOCK="$DIR_CONF/SurgeConf_AdBlock.list"
FILE_DIRECT="$DIR_CONF/SurgeConf_Manual.list"
FILE_PROXY="$DIR_CONF/SurgeConf_GlobalProxy.list"
FILE_NSFW="$DIR_CONF/SurgeConf_NSFW.list"
FILE_MEDIA="$DIR_CONF/SurgeConf_Media.list"
FILE_PROCESS_DIRECT="$DIR_CONF/SurgeConf_DirectProcess.list"
FILE_FIREWALL_PORTS="$DIR_CONF/SurgeConf_DirectPorts.list"

# Specifics
FILE_NETFLIX="$DIR_CONF/SurgeConf_Netflix.list"
FILE_SPOTIFY="$DIR_CONF/SurgeConf_Spotify.list"
FILE_YOUTUBE="$DIR_CONF/SurgeConf_YouTube.list"
FILE_TELEGRAM="$DIR_CONF/SurgeConf_Telegram.list"
FILE_GOOGLE="$DIR_CONF/SurgeConf_Google.list"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

print_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
print_success() { echo -e "${GREEN}[OK]${NC} $1"; }
print_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }

# Classification Logic
get_target_file() {
    local rule="$1"
    local policy="$2"
    local lower_rule=$(echo "$rule" | tr '[:upper:]' '[:lower:]')
    
    # CRITICAL: Exclude Firewall Port Rules
    if [[ "$rule" =~ ^(IN-PORT|DEST-PORT|SRC-PORT) ]]; then
        echo "SKIP_FIREWALL_RULE"
        return
    fi
    
    # Check Policy
    if [[ "$policy" == "REJECT" || "$policy" == "REJECT-DROP" ]]; then
        echo "$FILE_ADBLOCK"
        return
    fi

    # Check Comments (e.g., // NSFW or # NSFW)
    if [[ "$rule" =~ (//|#)[[:space:]]*(NSFW|R18|Adult|Porn) ]]; then
        echo "$FILE_NSFW"
        return
    fi
    
    if [[ "$rule" =~ (//|#)[[:space:]]*(Emby|Media) ]]; then
        echo "$FILE_MEDIA"
        return
    fi
    if [[ "$rule" =~ (//|#)[[:space:]]*(Netflix) ]]; then
        echo "$FILE_NETFLIX"
        return
    fi
    if [[ "$rule" =~ (//|#)[[:space:]]*(Spotify) ]]; then
        echo "$FILE_SPOTIFY"
        return
    fi
    if [[ "$rule" =~ (//|#)[[:space:]]*(YouTube) ]]; then
        echo "$FILE_YOUTUBE"
        return
    fi
    if [[ "$rule" =~ (//|#)[[:space:]]*(Telegram|TG) ]]; then
        echo "$FILE_TELEGRAM"
        return
    fi
    if [[ "$rule" =~ (//|#)[[:space:]]*(Google) ]]; then
        echo "$FILE_GOOGLE"
        return
    fi
    if [[ "$rule" =~ (//|#)[[:space:]]*(AI|OpenAI|Claude|ChatGPT) ]]; then
        echo "$DIR_CONF/SurgeConf_AI.list"
        return
    fi
    if [[ "$rule" =~ (//|#)[[:space:]]*(Gaming|Steam|Epic) ]]; then
        echo "$DIR_CONF/SurgeConf_Gaming.list"
        return
    fi
    if [[ "$rule" =~ (//|#)[[:space:]]*(Direct) ]]; then
        echo "$FILE_DIRECT"
        return
    fi
    if [[ "$rule" =~ (//|#)[[:space:]]*(Proxy) ]]; then
        echo "$FILE_PROXY"
        return
    fi
    if [[ "$rule" =~ (//|#)[[:space:]]*(AdBlock|Block) ]]; then
        echo "$FILE_ADBLOCK"
        return
    fi

    # Check Keyword Content (Smart Classification)
    if [[ "$lower_rule" =~ (kemono|xvideos|pornhub|jable|missav|18\+|sex|porn) ]]; then
        echo "$FILE_NSFW"
        return
    fi
    
    if [[ "$lower_rule" =~ (netflix|nflx) ]]; then echo "$FILE_NETFLIX"; return; fi
    if [[ "$lower_rule" =~ (spotify) ]]; then echo "$FILE_SPOTIFY"; return; fi
    if [[ "$lower_rule" =~ (youtube|googlevideo|youtu\.be) ]]; then echo "$FILE_YOUTUBE"; return; fi
    if [[ "$lower_rule" =~ (telegram|t\.me) ]]; then echo "$FILE_TELEGRAM"; return; fi
    if [[ "$lower_rule" =~ (google|gstatic|googleapis) ]]; then echo "$FILE_GOOGLE"; return; fi
    
    # Fallback based on Policy
    if [[ "$policy" == "DIRECT" ]]; then
        if [[ "$rule" =~ ^(PROCESS-NAME) ]]; then
            echo "$FILE_PROCESS_DIRECT"
            return
        fi
        echo "$FILE_DIRECT"
    elif [[ "$policy" == "Proxy" || "$policy" == *"Line"* || "$policy" == *"Node"* ]]; then
        echo "$FILE_PROXY"
    else
        echo "$FILE_DIRECT"
    fi
}

# Validation
if [ ! -f "$PROFILE_PATH" ]; then
    echo -e "${RED}Profile not found: $PROFILE_PATH${NC}"
    echo "Please edit PROFILE_PATH in this script"
    exit 1
fi

mkdir -p "$BACKUP_DIR"

# Locate Marker
line_num=$(grep -n "$MARKER" "$PROFILE_PATH" | cut -d: -f1 | head -n 1)

if [ -z "$line_num" ]; then
    echo -e "${YELLOW}Marker not found in profile. Nothing to ingest.${NC}"
    exit 0
fi

print_info "Marker found at line $line_num"

# Extract lines above marker
temp_above_marker=$(mktemp)
head -n "$((line_num - 1))" "$PROFILE_PATH" | tail -n 50 > "$temp_above_marker"

lines_to_ingest=()
lines_to_delete_count=0

buffer=()
while IFS= read -r line; do
    buffer+=("$line")
done < "$temp_above_marker"

found_rules_chunk=false

for (( idx=${#buffer[@]}-1 ; idx>=0 ; idx-- )) ; do
    line="${buffer[idx]}"
    clean_line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    if [ -z "$clean_line" ]; then
        if [ "$found_rules_chunk" = true ]; then
            break
        else
            continue
        fi
    fi

    if [[ "$clean_line" =~ ^# ]]; then
        break
    fi
    
    if [[ "$clean_line" =~ ^\[ ]]; then
        break
    fi

    if [[ "$clean_line" =~ ^(DOMAIN|IP-CIDR|PROCESS-NAME|USER-AGENT|URL-REGEX|DEST-PORT|IN-PORT|RULE-SET) ]]; then
        lines_to_ingest+=("$line")
        found_rules_chunk=true
        lines_to_delete_count=$((lines_to_delete_count + 1))
    else
        if [ "$found_rules_chunk" = true ]; then
            break
        fi
    fi
done

if [ ${#lines_to_ingest[@]} -eq 0 ]; then
    print_info "No new rules found above marker."
    exit 0
fi

print_info "Found ${#lines_to_ingest[@]} rules to ingest."

# Reverse the array
reversed_buffer=()
for (( idx=${#lines_to_ingest[@]}-1 ; idx>=0 ; idx-- )) ; do
    reversed_buffer+=("${lines_to_ingest[idx]}")
done

# Preview
echo ""
echo "---------- PREVIEW: RULES TO INGEST ----------"
printf "%-60s | %-20s | %-20s\n" "RULE" "POLICY" "TARGET LIST"
echo "----------------------------------------------------------------------------------------------------------------"

skipped_firewall_count=0
for rule in "${reversed_buffer[@]}"; do
    policy=$(echo "$rule" | awk -F, '{print $3}' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    [ -z "$policy" ] && policy="UNKNOWN"
    
    target_file=$(get_target_file "$rule" "$policy")
    
    if [[ "$target_file" == "SKIP_FIREWALL_RULE" ]]; then
        display_rule=$(echo "$rule" | cut -c1-60)
        printf "%-60s | %-20s | ${RED}%-20s${NC}\n" "$display_rule" "$policy" "SKIPPED (Firewall)"
        skipped_firewall_count=$((skipped_firewall_count + 1))
        continue
    fi
    
    target_name=$(basename "$target_file")
    display_rule=$(echo "$rule" | cut -c1-60)
    printf "%-60s | %-20s | ${CYAN}%-20s${NC}\n" "$display_rule" "$policy" "$target_name"
done
echo "----------------------------------------------------------------------------------------------------------------"
if [ $skipped_firewall_count -gt 0 ]; then
    print_warn "Skipped $skipped_firewall_count firewall port rules (should stay in module)"
fi
echo ""

EXECUTE=false
SKIP_BACKUP=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --execute) EXECUTE=true ;;
        --no-backup) SKIP_BACKUP=true ;;
        *) ;;
    esac
    shift
done

if [[ "$CI" == "true" ]]; then
    SKIP_BACKUP=true
fi

if [[ "$EXECUTE" == "false" ]]; then
    print_warn "Dry Run Mode. Use --execute to apply changes."
    exit 0
fi

# Execute ingestion
if [ "$SKIP_BACKUP" = false ]; then
    cp "$PROFILE_PATH" "$BACKUP_DIR/$(basename "$PROFILE_PATH").$timestamp.bak"
    print_success "Backed up profile to $BACKUP_DIR"
fi

ingested_count=0
skipped_count=0
for rule in "${reversed_buffer[@]}"; do
    policy=$(echo "$rule" | awk -F, '{print $3}' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    target_file=$(get_target_file "$rule" "$policy")
    
    if [[ "$target_file" == "SKIP_FIREWALL_RULE" ]]; then
        print_warn "Skipped firewall rule: $rule"
        skipped_count=$((skipped_count + 1))
        continue
    fi
    
    escaped_policy=$(printf '%s\n' "$policy" | sed 's:[][\/.^$*|]:\\&:g')
    clean_content=$(echo "$rule" | sed "s#,$escaped_policy##")

    echo "$clean_content" >> "$target_file"
    print_info "Appended '$clean_content' to $(basename "$target_file")"
    ingested_count=$((ingested_count + 1))
done

echo ""
print_success "Ingestion complete: $ingested_count rules processed"
if [ $skipped_count -gt 0 ]; then
    print_warn "Skipped $skipped_count firewall port rules (kept in module)"
fi

rm -f "$temp_above_marker"
